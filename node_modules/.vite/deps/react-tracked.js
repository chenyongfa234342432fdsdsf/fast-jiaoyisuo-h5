import {
  require_react_dom
} from "./chunk-T6VSAWLS.js";
import {
  require_react
} from "./chunk-FSLBSSP4.js";
import {
  __commonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/.pnpm/scheduler@0.23.0/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/.pnpm/scheduler@0.23.0/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i3) {
          var index = i3;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i3) {
          var index = i3;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a3, b2) {
          var diff = a3.sortIndex - b2.sortIndex;
          return diff !== 0 ? diff : a3.id - b2.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/.pnpm/scheduler@0.23.0/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/.pnpm/scheduler@0.23.0/node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+react-tracked@1.7.9_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/dist/index.modern.js
var import_react2 = __toESM(require_react());

// node_modules/.pnpm/registry.npmmirror.com+use-context-selector@1.3.10_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/use-context-selector/dist/index.modern.js
var import_react = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var import_react_dom = __toESM(require_react_dom());
var p = Symbol();
var a = Symbol();
var f = "undefined" == typeof window || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent) ? import_react.useEffect : import_react.useLayoutEffect;
var l = import_scheduler.unstable_runWithPriority ? (e3) => (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, e3) : (e3) => e3();
function w(r3) {
  const t3 = (0, import_react.createContext)({ [p]: { v: { current: r3 }, n: { current: -1 }, l: /* @__PURE__ */ new Set(), u: (e3) => e3() } });
  var o3;
  return t3[a] = t3.Provider, t3.Provider = (o3 = t3.Provider, ({ value: e3, children: r4 }) => {
    const t4 = (0, import_react.useRef)(e3), c3 = (0, import_react.useRef)(0), s3 = (0, import_react.useRef)();
    if (!s3.current) {
      const e4 = /* @__PURE__ */ new Set(), r5 = (r6) => {
        (0, import_react_dom.unstable_batchedUpdates)(() => {
          c3.current += 1, e4.forEach((e5) => e5([c3.current])), r6();
        });
      };
      s3.current = { [p]: { v: t4, n: c3, l: e4, u: r5 } };
    }
    return f(() => {
      t4.current = e3, c3.current += 1, l(() => {
        s3.current[p].l.forEach((r5) => {
          r5([c3.current, e3]);
        });
      });
    }, [e3]), (0, import_react.createElement)(o3, { value: s3.current }, r4);
  }), delete t3.Consumer, t3;
}
function E(e3, n3) {
  const o3 = (0, import_react.useContext)(e3)[p];
  if ("object" == typeof process && true && !o3)
    throw new Error("useContextSelector requires special context");
  const { v: { current: c3 }, n: { current: u3 }, l: s3 } = o3, i3 = n3(c3), [d2, a3] = (0, import_react.useReducer)((e4, r3) => {
    if (!r3)
      return [c3, i3];
    if (r3[0] === u3)
      return Object.is(e4[1], i3) ? e4 : [c3, i3];
    try {
      if (2 === r3.length) {
        if (Object.is(e4[0], r3[1]))
          return e4;
        const t3 = n3(r3[1]);
        return Object.is(e4[1], t3) ? e4 : [r3[1], t3];
      }
    } catch (e5) {
    }
    return [...e4];
  }, [c3, i3]);
  return Object.is(d2[1], i3) || a3(), f(() => (s3.add(a3), () => {
    s3.delete(a3);
  }), [s3]), d2[1];
}
function b(e3) {
  const t3 = (0, import_react.useContext)(e3)[p];
  if ("object" == typeof process && true && !t3)
    throw new Error("useContextUpdate requires special context");
  const { u: n3 } = t3;
  return n3;
}

// node_modules/.pnpm/registry.npmmirror.com+proxy-compare@2.1.0/node_modules/proxy-compare/dist/index.modern.js
var e2 = Symbol();
var t2 = Symbol();
var r2 = Symbol();
var n2 = Object.getPrototypeOf;
var o2 = /* @__PURE__ */ new WeakMap();
var s2 = (e3) => e3 && (o2.has(e3) ? o2.get(e3) : n2(e3) === Object.prototype || n2(e3) === Array.prototype);
var c2 = (e3) => "object" == typeof e3 && null !== e3;
var i2 = (n3, o3) => {
  let s3 = false;
  const c3 = (t3, r3, o4) => {
    if (!s3) {
      let s4 = t3.a.get(n3);
      s4 || (s4 = /* @__PURE__ */ new Set(), t3.a.set(n3, s4)), o4 && s4.has(e2) || s4.add(r3);
    }
  }, i3 = { f: o3, get(e3, t3) {
    return t3 === r2 ? n3 : (c3(this, t3), a2(e3[t3], this.a, this.c));
  }, has(e3, r3) {
    return r3 === t2 ? (s3 = true, this.a.delete(n3), true) : (c3(this, r3), r3 in e3);
  }, getOwnPropertyDescriptor(e3, t3) {
    return c3(this, t3, true), Object.getOwnPropertyDescriptor(e3, t3);
  }, ownKeys(t3) {
    return c3(this, e2), Reflect.ownKeys(t3);
  } };
  return o3 && (i3.set = i3.deleteProperty = () => false), i3;
};
var a2 = (e3, t3, o3) => {
  if (!s2(e3))
    return e3;
  const c3 = e3[r2] || e3, a3 = ((e4) => Object.isFrozen(e4) || Object.values(Object.getOwnPropertyDescriptors(e4)).some((e5) => !e5.writable))(c3);
  let l3 = o3 && o3.get(c3);
  return l3 && l3.f === a3 || (l3 = i2(c3, a3), l3.p = new Proxy(a3 ? ((e4) => {
    if (Array.isArray(e4))
      return Array.from(e4);
    const t4 = Object.getOwnPropertyDescriptors(e4);
    return Object.values(t4).forEach((e5) => {
      e5.configurable = true;
    }), Object.create(n2(e4), t4);
  })(c3) : c3, l3), o3 && o3.set(c3, l3)), l3.a = t3, l3.c = o3, l3.p;
};
var l2 = (e3, t3) => {
  const r3 = Reflect.ownKeys(e3), n3 = Reflect.ownKeys(t3);
  return r3.length !== n3.length || r3.some((e4, t4) => e4 !== n3[t4]);
};
var u2 = (t3, r3, n3, o3) => {
  if (Object.is(t3, r3))
    return false;
  if (!c2(t3) || !c2(r3))
    return true;
  const s3 = n3.get(t3);
  if (!s3)
    return true;
  if (o3) {
    const e3 = o3.get(t3);
    if (e3 && e3.n === r3)
      return e3.g;
    o3.set(t3, { n: r3, g: false });
  }
  let i3 = null;
  for (const c3 of s3) {
    const s4 = c3 === e2 ? l2(t3, r3) : u2(t3[c3], r3[c3], n3, o3);
    if (true !== s4 && false !== s4 || (i3 = s4), i3)
      break;
  }
  return null === i3 && (i3 = true), o3 && o3.set(t3, { n: r3, g: i3 }), i3;
};
var f2 = (e3) => !!s2(e3) && t2 in e3;
var y = (e3) => s2(e3) && e3[r2] || null;
var g = (e3, t3) => {
  const r3 = [], n3 = /* @__PURE__ */ new WeakSet(), o3 = (e4, s3) => {
    if (n3.has(e4))
      return;
    c2(e4) && n3.add(e4);
    const i3 = t3.get(e4);
    i3 ? i3.forEach((t4) => {
      o3(e4[t4], s3 ? [...s3, t4] : [t4]);
    }) : s3 && r3.push(s3);
  };
  return o3(e3), r3;
};

// node_modules/.pnpm/registry.npmmirror.com+react-tracked@1.7.9_2szjah6qrhd6fr2kgr64p4pjgm/node_modules/react-tracked/dist/index.modern.js
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    pathList.current = g(state, affected);
  });
  (0, import_react2.useDebugValue)(state);
};
var createTrackedSelector = (useSelector) => {
  const useTrackedSelector = () => {
    const [, forceUpdate] = (0, import_react2.useReducer)((c3) => c3 + 1, 0);
    const affected = /* @__PURE__ */ new WeakMap();
    const lastAffected = (0, import_react2.useRef)();
    const prevState = (0, import_react2.useRef)();
    const lastState = (0, import_react2.useRef)();
    (0, import_react2.useEffect)(() => {
      lastAffected.current = affected;
      if (prevState.current !== lastState.current && u2(prevState.current, lastState.current, affected, /* @__PURE__ */ new WeakMap())) {
        prevState.current = lastState.current;
        forceUpdate();
      }
    });
    const selector = (0, import_react2.useCallback)((nextState) => {
      lastState.current = nextState;
      if (prevState.current && prevState.current !== nextState && lastAffected.current && !u2(prevState.current, nextState, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
        return prevState.current;
      }
      prevState.current = nextState;
      return nextState;
    }, []);
    const state = useSelector(selector);
    if (typeof process === "object" && true) {
      useAffectedDebugValue(state, affected);
    }
    const proxyCache = (0, import_react2.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
    return a2(state, affected, proxyCache);
  };
  return useTrackedSelector;
};
var createContainer = (useValue, options) => {
  var _options, _options2;
  if (typeof options === "boolean") {
    console.warn("boolean option is deprecated, please specify { concurrentMode: true }");
    options = {
      concurrentMode: options
    };
  }
  const {
    stateContextName = "StateContainer",
    updateContextName = "UpdateContainer",
    concurrentMode
  } = options || {};
  const StateContext = w((_options = options) == null ? void 0 : _options.defaultState);
  const UpdateContext = (0, import_react2.createContext)((_options2 = options) == null ? void 0 : _options2.defaultUpdate);
  StateContext.displayName = stateContextName;
  UpdateContext.displayName = updateContextName;
  const Provider = (props) => {
    const [state, update] = useValue(props);
    return (0, import_react2.createElement)(UpdateContext.Provider, {
      value: update
    }, (0, import_react2.createElement)(StateContext.Provider, {
      value: state
    }, props.children));
  };
  const useSelector = (selector) => {
    if (typeof process === "object" && true) {
      const selectorOrig = selector;
      selector = (state) => {
        if (state === void 0) {
          throw new Error("Please use <Provider>");
        }
        return selectorOrig(state);
      };
    }
    const selected = E(StateContext, selector);
    (0, import_react2.useDebugValue)(selected);
    return selected;
  };
  const useTrackedState = createTrackedSelector(useSelector);
  const useUpdate = concurrentMode ? () => {
    if (typeof process === "object" && true && (0, import_react2.useContext)(UpdateContext) === void 0) {
      throw new Error("Please use <Provider>");
    }
    const contextUpdate = b(StateContext);
    const update = (0, import_react2.useContext)(UpdateContext);
    return (0, import_react2.useCallback)((...args) => {
      let result;
      contextUpdate(() => {
        result = update(...args);
      });
      return result;
    }, [contextUpdate, update]);
  } : () => {
    if (typeof process === "object" && true && (0, import_react2.useContext)(UpdateContext) === void 0) {
      throw new Error("Please use <Provider>");
    }
    return (0, import_react2.useContext)(UpdateContext);
  };
  const useTracked = () => [useTrackedState(), useUpdate()];
  return {
    Provider,
    useTrackedState,
    useTracked,
    useUpdate,
    useSelector
  };
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function memo(Component, propsAreEqual) {
  const WrappedComponent = (0, import_react2.forwardRef)((props, ref) => {
    Object.values(props).forEach(f2);
    return (0, import_react2.createElement)(Component, _extends({}, props, {
      ref
    }));
  });
  return (0, import_react2.memo)(WrappedComponent, propsAreEqual);
}
export {
  createContainer,
  createTrackedSelector,
  y as getUntrackedObject,
  memo
};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=react-tracked.js.map
